<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-18T05:04:56.032Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陌花 采撷</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis深入学习</title>
    <link href="http://yoursite.com/2019/08/18/mybatis01/"/>
    <id>http://yoursite.com/2019/08/18/mybatis01/</id>
    <published>2019-08-18T03:27:56.000Z</published>
    <updated>2019-08-18T05:04:56.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/08/18/mybatis01/milky-way-2695569_1920.jpg" alt></p><a id="more"></a><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="简单配置介绍"><a href="#简单配置介绍" class="headerlink" title="简单配置介绍"></a>简单配置介绍</h3><p>简单来说，Mybatis的配置主要分为以下几步（整合Spring之后有些就不需要了，但是一开始学习不建议直接整合Spring）：</p><ul><li><strong>编写POJO即JavaBean，最终的目的是将数据库中的查询结果映射到JavaBean上；</strong></li><li><strong>配置与POJO对应的Mapper接口：里面有各种方法，对应mapper.xml中的查询语句；</strong></li><li><strong>配置与POJO对应的XML映射：编写缓存，SQL查询等；</strong></li><li><strong>配置<code>mybatis-config.xml</code>主要的Mybatis配置文件：配置数据源、扫描mapper.xml等。</strong></li></ul><p>　　注意：以上的配置并没有严格的前后顺序；</p><p>一个比较清晰的配置流程图</p><p><img src="/2019/08/18/mybatis01/1566090966352.png" alt="1566090966352"></p><blockquote><p>可以看出mapper接口实现类的获得是通过mybatis-config.xml-&gt;SqlSessionFactoryBuilder-&gt;SqlSessionFacotry-&gt;SqlSession-&gt;mapper</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><ol><li><strong>SqlSessionFactoryBuilder</strong>：作用就是创建一个构建器，一旦创建了<code>SqlSessionFactory</code>，它的任务就算完成了，可以回收。</li><li><strong>SqlSessionFactory</strong>：作用是创建<code>SqlSession</code>，而<code>SqlSession</code>相当于JDBC的一个<code>Connection</code>对象，每次应用程序需要访问数据库，我们就要通过<code>SqlSessionFactory</code>创建一个<code>SqlSession</code>，所以<code>SqlSessionFactory</code>在Mybatis整个生命周期中存在<font color="red">（每个数据库对应一个<code>SqlSessionFactory</code>，是单例产生的）</font>。</li><li><strong>SqlSession</strong>：生命周期是存在于请求数据库处理事务的过程中，是一个线程不安全的对象（在多线程的情况下，需要特别注意），即存活于一个应用的请求和申请，可以执行多条SQL保证事务的一致性。</li><li><strong>Mapper</strong>：是一个接口，并没有实现类。它的作用是发送SQL，返回我们需要的结果或者发送SQL修改数据库表，所以它存活于一个<code>SqlSession</code>内，是一个方法级别的东西。当<code>SqlSession</code>销毁的时候，Mapper也会销毁。</li></ol><h3 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h3><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>即系统延迟执行查询，一般用于嵌套查询的时候，嵌套在内的SQL查询会延迟加载，等到真正需要使用该查询的时候才加载。就像懒人你说一下，他动一下，绝不会多执行半步，因此该特性也称之为懒加载。</p><p>懒加载必须配置<code>config.xml</code>，并且只能通过<code>association</code>或<code>collection</code>实现，毕竟只有在存在映射关系的业务场景里你需要使用懒加载</p><p>配置语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用时需要注意延迟加载必须使用resultMap，resultType不具有延迟加载功能。</p><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul><li>系统默认开启,缓存的范围为一个<code>SqlSession</code></li><li>只有一个SqlSession下的相同查询才会应用缓存，不同sqlSession下的即使查询相同一级缓存也不会生效</li></ul><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul><li><p>解决<code>SqlSession</code>相互隔离的情况，缓存范围为一个<code>Mapper</code>接口</p></li><li><p>二级缓存默认是不开启的，需要进行配置，Mybatis要求返回的POJO必须是可序列化的，即<font color="red">POJO实现Serializable接口。</font></p></li><li><p>缓存的配置只需要在<code>XML</code>配置<code>&lt;cache/&gt;</code>即可，或者指定算法，刷新时间间隔，缓存状态，大小等</p><blockquote><p>例：<cache eviction="LRU" readonly="true" flushinterval="100000" size="1024"></cache></p></blockquote></li></ul><p><img src="/2019/08/18/mybatis01/1566093841325.png" alt="1566093841325"></p><ul><li>映射语句文件中所有select语句将会被缓存；</li><li>映射语句文件中所有insert、update和delete语句会被刷新缓存；</li><li>缓存使用默认的LRU最近最少使用算法回收；</li><li>根据时间表，缓存不会任何时间顺序刷新</li><li>缓存会存储列表集合或对象的1024个引用</li><li>缓存被视为可read/write的缓存，意味着是不可以被共享的，而可以被安全地修改。</li></ul><h4 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h4><p>通过Mybatis实现的接口，使用redis等进行缓存</p><h3 id="实践配置"><a href="#实践配置" class="headerlink" title="实践配置"></a>实践配置</h3><p>待补充</p><h2 id="SqlSession原理"><a href="#SqlSession原理" class="headerlink" title="SqlSession原理"></a>SqlSession原理</h2><p><code>SqlSession</code>提供select/insert/update/delete方法</p><p>映射器（<code>Mapper</code>）其实就是一个动态代理对象，进入到<code>MapperMethod</code>的<code>execute</code>方法就能简单找到<code>SqlSession</code>的删除、更新、查询、选择方法.</p><p>从底层实现来说：通过动态代理技术，让接口跑起来，之后采用命令模式，最后还是采用了<code>SqlSession</code>的接口方法（<code>getMapper()</code>方法等到<code>Mapper</code>）执行SQL查询（也就是说Mapper接口方法的实现底层还是采用<code>SqlSession</code>接口方法实现的）。</p><p><strong>SqlSession重要的四个对象</strong></p><ol><li><strong>Execute</strong>：调度执行<code>StatementHandler</code>、<code>ParmmeterHandler</code>、<code>ResultHandler</code>执行相应的SQL语句；</li><li><strong>StatementHandler</strong>：使用数据库中<code>Statement（PrepareStatement）</code>执行操作，即底层是封装好了的<code>prepareStatement</code></li><li><strong>ParammeterHandler</strong>：处理SQL参数</li><li><strong>ResultHandler</strong>：结果集ResultSet封装处理返回。</li></ol><h3 id="SqlSession的四大对象"><a href="#SqlSession的四大对象" class="headerlink" title="SqlSession的四大对象"></a>SqlSession的四大对象</h3><h4 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a><mark>Execute</mark></h4><p>起java和数据库交互桥梁的作用，参与整个SQL执行过程。<strong>分类</strong></p><ol><li>SIMPLE简易执行器（默认）</li><li>REUSE重用预处理执行器</li><li>BATCH批量更新、批量专用处理器</li></ol><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutorType &#123;</span><br><span class="line">  SIMPLE, REUSE, BATCH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong></p><p>调度其他对象，完成预编译、配置参数和返回结果集</p><h4 id="StatementHanlder"><a href="#StatementHanlder" class="headerlink" title="StatementHanlder"></a><mark>StatementHanlder</mark></h4><p><strong>分类</strong>(分别对应不同执行器)</p><ul><li>SimpleStatementHandler</li><li>PrepareStatementHandler</li><li>CallableStatementHandler</li></ul><p><strong>作用</strong></p><p>专门处理数据库会话。进行预编译并调用ParameterHandler配置参数。大致来讲只是对数据库的连接做了封装</p><p><strong>工作流程</strong></p><ol><li>通过调用<strong>RoutingStatementHandler</strong>对象生成StatemenetHandler</li><li>RoutingStatementHandler查找相应的statementHandler对象</li><li>statementHandler调用数据库的方法</li></ol><h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a><mark>ParameterHandler</mark></h4><p><strong>作用</strong></p><p>对预编译的参数进行设置</p><p><strong>工作流程</strong></p><ol><li>从parameterObject中取到参数，然后使用typeHandler（注册在Configuration中）进行参数处理</li></ol><h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a><mark>ResultSetHandler</mark></h4><p><strong>作用</strong></p><p>组装结果返回结果集</p><h3 id="运行过程总结"><a href="#运行过程总结" class="headerlink" title="运行过程总结"></a>运行过程总结</h3><ol><li><strong>prepare预编译</strong></li><li><strong>parameterize设置参数</strong></li><li><strong>doUpdate/doQuery执行SQL</strong></li></ol><p>神人的总结</p><p><img src="/2019/08/18/mybatis01/1566098446042.png" alt="1566098446042"></p><p>参考链接</p><p><a href="https://www.cnblogs.com/jian0110/p/9387941.html" target="_blank" rel="noopener">Mybatis缓存（1）——–系统缓存及简单配置介绍</a></p><p><a href="https://www.cnblogs.com/jian0110/p/9452592.html" target="_blank" rel="noopener">Mybatis的SqlSession运行原理</a></p><p><a href="https://www.cnblogs.com/sword-successful/p/7400685.html" target="_blank" rel="noopener">MyBatis从入门到放弃六：延迟加载、一级缓存、二级缓存</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/08/18/mybatis01/milky-way-2695569_1920.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>云计算设备学习</title>
    <link href="http://yoursite.com/2019/08/17/cloudcompute01/"/>
    <id>http://yoursite.com/2019/08/17/cloudcompute01/</id>
    <published>2019-08-17T13:54:03.000Z</published>
    <updated>2019-08-17T15:00:36.603Z</updated>
    
    <content type="html"><![CDATA[<p>开坑~</p><a id="more"></a><p>fusioncompute</p><p>支持的存储设备</p><ul><li>LUN</li><li>本地磁盘</li><li>Advanced SAN存储池</li><li>fusionstorage</li><li>NAS共享目录</li></ul><p>fusionstroage</p><h1 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h1><p>实验环节  </p><p><img src="/2019/08/17/cloudcompute01/assets/1566052588292.png" alt="1566052588292"></p><p>ServiceCenter：用于支持基础业务，包括发放虚拟机</p><p>openstack可以运行在计算节点和控制节点，通过连接fusioncompute进行控制</p><p>IP地址规划</p><p><img src="/2019/08/17/cloudcompute01/assets/1566053456257.png" alt="1566053456257"></p><h2 id="安装主机"><a href="#安装主机" class="headerlink" title="安装主机"></a>安装主机</h2><p>基本拓扑</p><p><img src="/2019/08/17/cloudcompute01/assets/1566054005684.png" alt="1566054005684"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开坑~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UI设计尺寸问题——移动端</title>
    <link href="http://yoursite.com/2019/08/17/pixel/"/>
    <id>http://yoursite.com/2019/08/17/pixel/</id>
    <published>2019-08-17T03:31:41.000Z</published>
    <updated>2019-08-17T10:39:40.611Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在做前端的UI，本来以为会是一件很简单的事情，但一来二去也搞了整整一天。其中最让我郁闷的是在了PS设置画布尺寸的时候没有做充分的调查，理解错了同学口中的尺寸意义，导致UI画完了才发现尺寸整整小了一圈😂怎么办？重画呗~</p><p>这次我吸取教训，整理了相关资料，这次一定要一举击破像素尺寸问题！</p><a id="more"></a><h2 id="物理尺寸"><a href="#物理尺寸" class="headerlink" title="物理尺寸"></a>物理尺寸</h2><h3 id="英寸"><a href="#英寸" class="headerlink" title="英寸"></a>英寸</h3><p>英寸(inch)是衡量设备尺寸的常用单位</p><p>它代表的是屏幕对角线的长度</p><blockquote><p>一英寸≈2.54cm</p></blockquote><p><img src="/2019/08/17/pixel/16ac3a65a02a95cd" alt="img"></p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>像素是屏幕的最小单位，所有图片都是由无数个像素点构成。</p><p>像素应该是用来衡量尺寸的，像素点和尺寸成正比</p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><blockquote><p>分辨率即垂直和水平方向上的像素点数,例如<code>1080*1920</code></p></blockquote><p>指具体设备的屏幕像素尺寸，一般我们所说的手机或者电脑等物理设备的分辨率的时候就是指屏幕分辨率</p><p>屏幕分辨率越高不代表屏幕越清晰，这还要取决设备的物理尺寸。换句话说，分辨率要和物理尺寸搭配才能体现清晰度，因为它直接能表现的是屏幕所能容纳的总的像素点数，如果设备物理尺寸不同，比较分辨率应该意义不大。当然这里的像素应该指的是物理像素，这点之后会提到。</p><p><strong>这里要记住的<mark>是屏幕分辨率/设备独立像素(逻辑像素) = 倍率（设备像素比）</mark>这个结果才能真正定义清晰度</strong></p><h3 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h3><p>即图片所含的像素点数，表示一张图片在垂直和水平方向上的像素点数</p><p>和屏幕分辨率的定义差不多，只不过一个是定义屏幕的一个是定义图片的。同一尺寸下分辩率越高，图片越清晰</p><p><img src="/2019/08/17/pixel/16ac3a653fc492ca" alt="img"></p><h3 id="PPI（Pixel-per-Inch）"><a href="#PPI（Pixel-per-Inch）" class="headerlink" title="PPI（Pixel per Inch）"></a>PPI（Pixel per Inch）</h3><blockquote><p>每英尺包含的像素点数，可以用来描述屏幕的清晰程度</p></blockquote><p>PPI越高，图片质量越清晰。</p><p>这里注意在设计的时候一般约定</p><p><mark><strong>手机屏幕使用72PPI，海报使用300PPI</strong></mark></p><p>据说PPI达到300以上，就会给人真实感，因此海报的PPI要达到这个数值，而手机屏幕如果<code>PPI</code>设置过大，会导致加载过慢，卡顿的现象，一般<code>72PPI</code>也够用了</p><p><img src="/2019/08/17/pixel/assets/20180403172033656" alt></p><p><strong>PPI的计算公式</strong></p><p><img src="/2019/08/17/pixel/equation.svg" alt></p><p><strong>DPI（Dot per Inch）</strong></p><p>每英寸包括的点数。它可以是屏幕像素点、图片像素点也可以是打印机的墨点。</p><p><strong>在描述图片和屏幕的时候可以认为DPI和PPI两者等价</strong></p><p>在使用打印机的时候，由于打印机打印的点不是规则排列的，打印点之间会存在空隙，因此<code>DPI</code>也被称之为打印点的密度</p><p>打印机的DPI越高，打印图像的精细程度越高，同时墨点的耗费量和打印时间也越长</p><h2 id="逻辑像素和物理像素"><a href="#逻辑像素和物理像素" class="headerlink" title="逻辑像素和物理像素"></a>逻辑像素和物理像素</h2><p>以上我们看到的像素都是真实的像素，是物理像素</p><p>但是随着技术的发展出现了逻辑像素，即由多个物理像素组成一个逻辑像素。</p><p>这是由乔布斯在<code>Iphone4</code>的发布会上发布的视网膜屏幕（<code>Retina Display</code>）首次提出的</p><p><img src="/2019/08/17/pixel/16ac3a658fe8b6ff" alt="img"></p><p>一个很直观的对比就是，由逻辑像素（假设一个逻辑像素由3个物理像素组成）组成的分辨率为1080*1920的图片，和一个由物理像素组成的分辨率为<code>1080*1920</code>的图片，在像素总量一定的前提下，前者的图片尺寸是后者的3倍，试想想如果把这个3倍的尺寸图片压缩到1倍的图片中，是不是清晰度骤然就提升了呢？</p><h3 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h3><p>设备独立像素，指设备的原始尺寸，这里的像素是逻辑像素</p><p>打开<code>chrome</code>的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</p><p><img src="/2019/08/17/pixel/16ac3a664842c93c" alt="img"></p><h3 id="设备像素比DPR"><a href="#设备像素比DPR" class="headerlink" title="设备像素比DPR"></a>设备像素比DPR</h3><p><code>device pixel ratio</code>简称<code>DIP</code>或<code>DP</code>,指设备的物理像素和逻辑像素之比，也称之为倍数</p><h2 id="开发问题"><a href="#开发问题" class="headerlink" title="开发问题"></a>开发问题</h2><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><code>iOS</code>的尺寸单位为<code>pt</code>，<code>Android</code>的尺寸单位为<code>dp</code>，<code>React Native</code>中没有指定明确的单位，它们其实都是设备独立像素<code>dp(Device Pixel)</code>。</p><h3 id="WEB端"><a href="#WEB端" class="headerlink" title="WEB端"></a>WEB端</h3><p>CSS像素使用的是设备独立像素(逻辑像素)</p><p>UI准备图的时候根据屏幕的质量（2倍屏或3倍屏）准备2倍和3倍的像素尺寸进行绘图</p><p>在写<code>CSS</code>时，我们用到最多的单位是<code>px</code>，即<code>CSS像素</code>，当页面缩放比例为<code>100%</code>时，一个CSS像素等于一个设备独立像素。</p><p>但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。</p><blockquote><p>页面的缩放系数 = CSS像素 / 设备独立像素</p></blockquote><h2 id="屏幕问题"><a href="#屏幕问题" class="headerlink" title="屏幕问题"></a>屏幕问题</h2><p>我们常使用P和K衡量屏幕质量</p><blockquote><p><strong>P代表的屏幕纵向的像素个数</strong></p></blockquote><p>1080P即代表屏幕纵向有1080个像素</p><blockquote><p><strong>K代表的屏幕横向的像素个数</strong></p></blockquote><p>K代表屏幕横向有几个1024像素，像像素超过4096一般就称之为4K屏</p><p>参考文章：<a href="https://juejin.im/post/5cddf289f265da038f77696c#heading-46" target="_blank" rel="noopener">关于移动端适配，你必须要知道的</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在做前端的UI，本来以为会是一件很简单的事情，但一来二去也搞了整整一天。其中最让我郁闷的是在了PS设置画布尺寸的时候没有做充分的调查，理解错了同学口中的尺寸意义，导致UI画完了才发现尺寸整整小了一圈😂怎么办？重画呗~&lt;/p&gt;
&lt;p&gt;这次我吸取教训，整理了相关资料，这次一定要一举击破像素尺寸问题！&lt;/p&gt;
    
    </summary>
    
    
      <category term="UI设计" scheme="http://yoursite.com/tags/UI%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>当我们面对命运的时候，我们在想些什么？</title>
    <link href="http://yoursite.com/2019/07/18/destiny/"/>
    <id>http://yoursite.com/2019/07/18/destiny/</id>
    <published>2019-07-18T01:08:00.000Z</published>
    <updated>2019-07-18T04:07:36.049Z</updated>
    
    <content type="html"><![CDATA[        <div id="aplayer-DQMCptFR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-DQMCptFR"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "第5号交响曲《命运》",              author: "佐渡 裕 / ベルリン・ドイツ交響楽団",              url: "http://music.163.com/song/media/outer/url?id=461601898.mp3",              pic: "http://p2.music.126.net/IkEQquKQt6u-8EVeWdHMpw==/18780758115854708.jpg?param=130y130",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>“北海，我只能告诉你，在那之前要多想”</p><a id="more"></a><hr><p>当我点开它的一瞬间，我在想什么？无奈？恐惧？有对过去的忏悔？有在默默祈祷？不管怎样，我至少能确定一点。</p><p><font color="#F76957"><strong>那一刻，我被命运主宰了。</strong></font></p><p>我相信命运吗？在我保持理智的时候，我是会否认的，但每当在那些关键的节点的时候，我不得不承认，我无能为力，如果说我无法控制我未来走向，那究竟是谁在控制它？大概就是命运吧。</p><h3 id="什么是命运？"><a href="#什么是命运？" class="headerlink" title="什么是命运？"></a><font csolor="#F76957"><strong>什么是命运？</strong></font></h3><span class="bg" title="交给之后的你来处理了" style=" background-color: #F5F6F7"><a href="#" style="color:#F5F6F7; text-decoration:none;" onmouseover="this.style.cssText='color:black; text-decoration:none; '" onmouseout="this.style.cssText='color:#F5F6F7;text-decoration:none'">~很显然，我们暂时无法得知命运地全貌，但是我们能粗瞥它的真容。命运不会偏袒任何一方，它所做的所有都是合理的，尽管有时候会由于我们认知的不足而出现一些看似偶然，但实则必然的事情。它是绝对公正的。但是我们需要绝对公正吗?我不知道，这个问题用我现在的思维能力无法解答。但是很有趣，希望有一天我能知道</a></span><p>如果说命运只是冥冥中注定的天数，是一成不变的，那只是懒人们的借口，只是他们不想思考和规划未来而做的缴械投降。令人讽刺的是，每当人开始面对命运的时候，往往是他思维最活跃的时候。至少我是这样的。</p><p>我知道这次我又是无能为力，面对即将出现的成绩我无可奈何，我任由命运给我答案。但是也正是这个节点，我开始疯狂回忆自己的所作所为，开始假想各种各样的结局，明明知道自己的结局已经是确定的，但是潜意识中，仍希望做着看似无谓的挣扎。这就是人性吧。</p><p>我把内心的挣扎归为是自由意志的体现，这也是为什么人类能不断前进的原因。因为人类就是这样一种为了否定命运而存在的动物。因为对自由的渴望，人类不断反抗着，希望掌握自己的命运，因此他们成功了，他们自由了，所以人成了万物的灵长。永不停止抗争和失去对自由的追求，这是我们的天性。</p><h3 id="命运由我不由天"><a href="#命运由我不由天" class="headerlink" title="命运由我不由天"></a><font color="#F76957">命运由我不由天</font></h3><p>命运由我不由天。尽管有的时候我们无法主宰命运，但是不能让命运决定我们的未来。道路是曲折的，但是前途是光明的，在我们的自由意志下，目标的实现是必然的。</p><p>只是，现在的我，开始开始承认命运的主宰地位了。当面对命运的时候，巨大的无力感让我无可奈何。束手无策的我失去了自己的自由。尽管思考再多，我也打不倒命运。</p><p><mark><font color="#F76957"><strong>“北海，我只能告诉你，在那之前要多想”</strong></font></mark></p><p>是啊，如果人都只是在大难临头的时候才思考，那他离毁灭也不远了。比这更可怕的是被击倒后就习惯了下跪，再痛的伤愈合后也被忘得一干二净。想，要多想，要无时不刻地想。既然记忆总会趋向逝去，那就就不断地刷新强化，用毅力去坚持！这才是我们的自由意志！</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-DQMCptFR&quot; class=&quot;aplayer aplayer-tag-marker&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
            &lt;pre class=&quot;aplayer-lrc-content&quot;&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script&gt;
          var ap = new APlayer({
            element: document.getElementById(&quot;aplayer-DQMCptFR&quot;),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: &quot;第5号交响曲《命运》&quot;,
              author: &quot;佐渡 裕 / ベルリン・ドイツ交響楽団&quot;,
              url: &quot;http://music.163.com/song/media/outer/url?id=461601898.mp3&quot;,
              pic: &quot;http://p2.music.126.net/IkEQquKQt6u-8EVeWdHMpw==/18780758115854708.jpg?param=130y130&quot;,
              lrc: &quot;&quot;
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        &lt;/script&gt;



&lt;p&gt;“北海，我只能告诉你，在那之前要多想”&lt;/p&gt;
    
    </summary>
    
      <category term="日记本" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0%E6%9C%AC/"/>
    
    
      <category term="自省" scheme="http://yoursite.com/tags/%E8%87%AA%E7%9C%81/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>迷失的人不再迷失，相逢的人还会再相逢</title>
    <link href="http://yoursite.com/2019/07/03/Spirited_Away/"/>
    <id>http://yoursite.com/2019/07/03/Spirited_Away/</id>
    <published>2019-07-03T02:05:40.000Z</published>
    <updated>2019-07-03T07:04:03.586Z</updated>
    
    <content type="html"><![CDATA[        <div id="aplayer-qGdxfKhl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qGdxfKhl"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "いつも何度でも",              author: "伊藤サチコ",              url: "http://music.163.com/song/media/outer/url?id=584155.mp3",              pic: "http://p1.music.126.net/GYWkXtrnAawOWO2nfLg3PA==/109951163028865726.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>    <p><img src="/2019/07/03/Spirited_Away/6650364e251f95ca19ca4b34c7177f3e660952d4.jpg" alt="海报"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我没有修改文字的习惯。我以为但凡是写下的都是内心的真实想法，都是转瞬即逝的珍贵记忆，尽管有时候写出来的东西混乱不堪，但是我依然能从这些文字总体会到当时我的思绪，所以说文字是一把打开记忆之门的钥匙，同时也是我不断反省的工具。因此所有的文字我都原样保留，特此说明，引以为警。</p><a id="more"></a><p>2019年7月2日，正值《千与千寻》在映。抱着重温经典，平静自己之前浮躁的心的想法，我又是一个人包场去看了电影（国语版），看完后心中已有不小感触，恰逢室友准备召开期末寝室大会，从而打开了我自我反省的大门 ，我回顾着失败的过往，迷失在自我放弃的漩涡里。</p><p>本以为又将是一次痛苦的折磨，但是室友们的敞开心扉，让我真的发现了一丝的光亮。我自诩孤独，只是我一直在抗拒，或者说一直在逃避。但是我真的不是一个人，他们就是我的朋友。我无需在今晚改变什么，但是我只确定一点，以后必须坚定不移地坚持这一点认识：</p><blockquote><p><font color="#F76957"><strong>我不是一个人，我有真正的朋友，对朋友请敞开心扉。</strong></font></p></blockquote><p><img src="/2019/07/03/Spirited_Away/movie.jpeg" alt></p><hr><p>2019.7.2</p><blockquote><p>无面男</p></blockquote><p>他像我但不是我。我们都是孤独中找不到自我的人，我们都是被欲望填充就失去自我的人。他终究是单纯的，最后也能找到自己的归宿。而我一直都是残缺的，对世界的联系是脆弱的，故事总是美好的，即使有无奈的结局但至少还能庆幸是虚假的，我是真实存在的，所有关于我的一切都是真实地残酷，这是一条无法回头的路，没有一丝的怜悯，没有一丝的侥幸，走着走着只能像是一滴浊泪坠入汪洋，分解地悄无声息又消失地无可奈何，世界不会因此有任何改变，存在也不会有任何意义，     </p><p><strong>人为什么要白白走这一遭啊！</strong></p><p><img src="/2019/07/03/Spirited_Away/great.jpg" alt="巨人名场面"></p><hr><p>2019.7.3</p><blockquote><p>我犯了一个很大的错。我直到现在都没有真正地去接纳这个世界。我是孤独的，因为我总是把眼光局限在了自己所能触及的范围内，被自己的臆想所束缚，所想即所得，犯了唯心主义的大忌。其次，我一直都是知道路的，但是我一直在路旁伫立。在静止的时间你确实可以好好反省，但是没有了流动，你就无法打破自己设下的环，想得太多，所得的结果却总是原地打转，只有负能量在不断放大，最终毒害了自己。</p><p>所以，不要停下来啊！</p><p>遇到自己解决不了的事情就大胆说出来，所有的烦恼和困惑请及时抛弃，只有大胆地迈出这一步，你才能走出怪圈。造物主是缺乏想象力的，人们外貌特征总是会和别人有部分地相似，所有经历都像是别人经历的东拼四凑，因此没有人是特殊的，所有人都是平凡的。但平凡的人们却是富有想象力的，人们对于同样的事情，会有着不同的看法，会有着千奇百怪的解决办法，正因为大家都有一段经历的相似性，因此所有的解决方法才有了借鉴的可能，人因此能总结前人留下 的经验，为自己的经历增添新的思路看法。我们的目标从来不是解决完世界的所有问题，我们也不期望问题都有一个最佳的答案，因为我们在思考问题的过程中所迸发的无穷的智慧才是我们想要传承和发扬的宝藏。</p><p>因此人生是值得的。</p></blockquote><p>再一次看看《千与千寻》，虽说是想找寻一下内心的平静，但是其实也有很大程度是因为自诩电影爱好者总想给自己赋予一些专业度。希望能通过再次回顾电影去探索电影背后的寓意，来满足自己的虚荣心。事实证明，尽管第二次重温电影，我依然没有能抓住电影的深层含义，开场第一幕音乐一响起，我就像浸泡在了浴缸里一样，舒服得不想再去动脑子，只想好好沉浸在电影带来的观感中。再加上后半段的剧情自己也已记忆模糊，所以只晓得跟着剧情走了，别的再不想（果然还是不懂脑子比较好~），总的来说，还是值得的 。</p><p>尽管如此，第二次观影还是给我带来了一些不一样的感触。比如第一次让我开始有所反省的就是无脸男的登场。无脸男喜欢小千，却不懂什么是爱 ，我反正觉得这就是我的影子。我渴望成功和荣誉（或者爱情也不是不可以–）但是却找不到方法，或者说很迷茫。无脸男为了讨小千欢心，不断地思考什么是人所想要的，最后他发现了金子。金子珍贵又充满的魔力，单纯的他很快就迷失在了其中，金子满足了他的欲望，欲望不断地膨胀，最后可以扭曲一个人的性格。被欲望填充的无脸男变得丑陋，油腻，狂妄自大，深陷其中不能自拔。进入大学的我也是一样的迷茫，四处碰壁，或沉迷于欲望中，大学的自由让我不得不面对周围许许多多的诱惑，然而我没有成功地克制住自己，任由欲望不断膨胀，我开始失去目标，开始变得无奈和颓废，明知道自己的祸根在哪，可就是无法舍弃。我再也回不到原来的状态了，那个永不放弃，单纯，勇敢的少年，正提前变得油腻，失去斗志。怎么办？电影中解决方法很有趣，无脸男吃多了欲望，多运动就好。随着运动不断排泄出无用的欲望，直到自己再一次孑然一身，身体也重新变得空灵起来。所以简单就是一种态度。我那两个在衡中的室友想念原来的生活方式也不是没有道理，现在的我几乎也要被他们说服了。</p><blockquote><p><font color="#F76957"><strong>大学的我们有太多的选择，可很多时候我们又不会选择</strong></font></p></blockquote><p>这样的话，不如我们就从头来过，回到高中简简单单的模式，给自己减负。这就是舍得。</p><p>全片最让我感动的就是千寻和无脸男坐上有轨列车，列车在水上缓缓驶过，车外风景变换无常，车上旅客行路匆匆，我和你肩并肩坐着，不说话，就很美好。</p><p><img src="/2019/07/03/Spirited_Away/partner.jpg" alt="陪伴"></p><p>​        记住自己的名字，忘记了就找不回自我。简单就是一句话，不忘初心，方得始终。</p><p>​        电影播完，字幕出场，伴随着《いつも何度でも》的ED响起，又是泛起一阵不舍，千言万语化作一句话：“这就是人生啊”。 立下一个不算是Flag的Flag：以后还是会再见的，<font color="red">《千と千尋の神隠し》</font></p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-qGdxfKhl&quot; class=&quot;aplayer aplayer-tag-marker&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
            &lt;pre class=&quot;aplayer-lrc-content&quot;&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script&gt;
          var ap = new APlayer({
            element: document.getElementById(&quot;aplayer-qGdxfKhl&quot;),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: &quot;いつも何度でも&quot;,
              author: &quot;伊藤サチコ&quot;,
              url: &quot;http://music.163.com/song/media/outer/url?id=584155.mp3&quot;,
              pic: &quot;http://p1.music.126.net/GYWkXtrnAawOWO2nfLg3PA==/109951163028865726.jpg&quot;,
              lrc: &quot;&quot;
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        &lt;/script&gt;    

&lt;p&gt;&lt;img src=&quot;/2019/07/03/Spirited_Away/6650364e251f95ca19ca4b34c7177f3e660952d4.jpg&quot; alt=&quot;海报&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我没有修改文字的习惯。我以为但凡是写下的都是内心的真实想法，都是转瞬即逝的珍贵记忆，尽管有时候写出来的东西混乱不堪，但是我依然能从这些文字总体会到当时我的思绪，所以说文字是一把打开记忆之门的钥匙，同时也是我不断反省的工具。因此所有的文字我都原样保留，特此说明，引以为警。&lt;/p&gt;
    
    </summary>
    
      <category term="日记本" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0%E6%9C%AC/"/>
    
    
      <category term="千与千寻" scheme="http://yoursite.com/tags/%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB/"/>
    
      <category term="电影" scheme="http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="自省" scheme="http://yoursite.com/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务初识</title>
    <link href="http://yoursite.com/2019/06/14/shiwu/"/>
    <id>http://yoursite.com/2019/06/14/shiwu/</id>
    <published>2019-06-14T01:54:04.000Z</published>
    <updated>2019-07-18T01:15:38.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote><p>本篇共2895字，阅读大约需要6分钟</p></blockquote><p>本次将向大家科普一些数据库事务相关知识。为什么选择数据库作为本次介绍的主角？</p><p>数据库是现代网络的重要组成部分。在信息爆炸的大数据时代，各行各业都因为大幅爆发的数据而正变得蒸蒸日上；海量，多样且在高速产生的数据正迸发着前所未有的价值。可以说，数据改变了我们的生活，也在创造我们的未来。因此，我们越来越需要更加灵活，功能强大的数据库来帮助我们存储数据，处理数据。随着时代的发展，掌握数据库操作相关技术已经是从事ICT行业的相关人员的必备选择。</p><a id="more"></a><p>但是鉴于篇幅有限，同时为了提供给大家一些自我学习的空间，因此本次将不再过多涉及数据库的基础操作，而是选择事务这个相对独立而且具有一定介绍意义的概念给大家进行简单的科普。事务是数据库系统中非常重要的概念，不仅是数据库学习的的必经之路，同时也是学习数据库高级特性，进阶提升的重要基础。因此本次介绍权当抛砖引玉，大家如果感兴趣，可以自己下去多多研究，充实自己，扩展视野。接下来，就让我们开始探索之旅吧~</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>在正式介绍事务之前，让我们先充充电，大致了解一些基本概念，这些在之后的学习将会用到。</p><ol><li>什么是数据库</li></ol><blockquote><p>“数据库”是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合</p></blockquote><ol start="2"><li>什么是数据库管理系统</li></ol><blockquote><p>数据库管理系统（Data Base Management System，简称DBMS）是位于用户应用程序与操作系统之间的一层数据管理软件，是数据库系统的核心组成部分。<strong>为用户或应用程序提供访问数据库的方法：包括数据库的建立、查询、更新以及各种数据控制</strong>。</p></blockquote><p>数据库管理系统不仅允许单个用户查询和修改数据，也可以支持多人操作。多人操作就会出现导致操作并发，出现拥塞。</p><ol start="3"><li>什么是锁</li></ol><blockquote><p>锁是数据库服务器用来控制数据资源被并行使用的一种机制。被锁的对象只允许持有用户操作，只有等锁释放后，其他用户才能有拥有锁的机会。</p><p>大部分数据库使用下面两种锁策略：</p><ul><li>写操作需要申请写锁，读操作申请读锁，一个表一次只能分配一个写锁，并且拒绝读请求直到写锁释放</li><li>写操作需要写锁，读操作不需要锁</li></ul><p>其中常见的数据库如mysql可以根据不同的存储引擎选择不同的锁策略</p></blockquote><ol start="4"><li>锁的粒度</li></ol><blockquote><p>即锁的范围，在数据库中，服务器可以在3个不同级别应用锁</p><ul><li><p>表锁</p><p>阻止多用户同时修改同一张表的数据</p></li><li><p>页锁</p><p>阻止多用户同时修改某表中的一页</p></li><li><p>行锁</p><p>阻止多用户同时修改某表中的某一行</p></li></ul></blockquote><ol start="5"><li>什么是存储引擎</li></ol><blockquote><p>数据库存储引擎是数据库底层软件组织,数据库管理系统(DBMS)使用数据引擎进行创建、查询、更新和删除数据，不同的存储引擎提供不同的存储机制、锁定水平等功能。</p><p>锁的行为是由存储引擎决定的，存储引擎使用不当会引发死锁现象</p><p>例如mysql有三种存储引擎：InnoDB  MyISAM  MEMORY</p></blockquote><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>我们从一个场景开始说起。假设一个人在银行办理转账业务，现在他要将1万元转账到另一个人，按一般情况，转账的过程几乎是秒级完成，但是，当我们将过程拆解，转账步骤可分为3步：1.查询账户余额是否大于1万元，2.从原账户上减去1万元，3.在对方账户上增加1万元。我们可以发现，其实只要其中任意一个环节出现偏差，都有可能造成无法挽回的重大损失。因此，为了确保银行里金额不会损失，我们可以这么做：将这一万元暂时缓存下来，只有确认对方账户已完成扣除款项的操作，才将这一万元增加到对方账户；否则，所有操作都失效，原账户取消扣除款项，对方账户也不会无故增加数量，我们把这种操作称之为事务回滚，转账的操作就是一个事务。</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>世界上总是充满各种各样的意外，很多都是我们无法左右的，例如服务器的损坏，突然的断电，系统的崩溃等等，如果没有事务的存在，数据库的操作可靠性将无法得到保证。但这些的前提是事务本身应当有完备的标准来确保事务本身的可靠性。因此，那些前辈们给事务指定了ACID四大特性，只有严格通过了ACID测试，事务才能发挥其作用。</p><ol><li><p>原子性</p><blockquote><p>一个事务必须被视为不可分割的最小工作单元，整个事务种的所有操作要么全部提交成功，要么全部失败回滚，对于一个 事务来说，不可能 执行其中一部分操作。</p></blockquote></li><li><p>一致性</p><blockquote><p>数据库总是从一个一致性的状态转移到另一个一致性的状态，事务不能破坏数据库的完整性以及业务逻辑的一致性。比如无论转账成功或失败，都不可能会多出或减少1万元，金额总数是不变的。&gt;</p></blockquote></li><li><p>隔离性</p><blockquote><p>一个事务在提交前的修改对其他事务通常是不可见的。一个事务不应影响其他事务的运行效果。</p></blockquote></li><li><p>持久性</p><blockquote><p>一旦事务提交，其修改是不可逆的。</p></blockquote></li></ol><p>事务的ACID特性保证了数据库操作的安全性和可靠性，但实际操作总没有想象中那么简单。同时，添加事务也需要数据库系统进行更多额外的工作，这对数据库系统的性能提出了一定的要求。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>实际上，要让事务保证完全隔离依然是一件十分困难的事情 ，完全的隔离要求数据库同一时间只能执行一个事务，这样会严重影响性能。现实中，往往是多个事务并发执行。</p><p>一旦隔离性无法得到保证，数据库的读写就会面临如下情况</p><ol><li>脏读：事务读取了未提交的数据。例如事务A读取了事务B的更新的数据，但是事务B回滚了，导致A读取的为脏数据</li><li>不可重复读：事务A读取同一数据两次，但是在两次之间事务B对该数据进行了修改并提交，导致事务A读取两次读取不一致</li><li>幻读：事务A修改全表的数据，在未提交时，事务B向表中插入或删除数据，导致事务A读取的数据与需要修改的数据不一致</li></ol><p>对此，sql标准中指定了四种隔离级别：</p><ol><li><p>未提交读（READ UNCOMMITTED）</p><p>事务可以读取为提交的数据，不做隔离控制</p></li><li><p>提交读（READ COMMITTED）</p><p>不允许未提交读,一个事务开始前，只能“看见”已提交的事务修改，是大部分数据库的默认隔离级别（mysql除外）</p></li><li><p>可重复读（REPEATED READ）</p><p>保证同一事务中多次读取同一记录的结果是一致的，一般方法是事务中对符合条件的记录上排他锁，这样其他事务不能对该事务操作的数据进行修改，是mysql的默认隔离级别</p></li><li><p>可串行化(SERIALIZABLE)</p><p>是最高隔离级别，通过强制事务串行执行，在读取的每一行数据上加锁，导致其他事务不能对数据进行操作（包括增加、删除和修改），但是此级别也要注意大量锁的超时会极大地影响性能。</p></li></ol><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（READ UNCOMMITTED）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>提交读（READ COMMITTED）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（REPEATED READ）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可串行化(SERIALIZABLE)</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id="阻塞和死锁"><a href="#阻塞和死锁" class="headerlink" title="阻塞和死锁"></a>阻塞和死锁</h3><p>谈到并发就大致谈一下阻塞的概念</p><p>当多个事务对某一资源进行锁定时，其他没有分配到锁的事务势必等待锁的释放，这就造成了阻塞。</p><p><img src="/2019/06/14/shiwu/880402-20160705084123342-493440158.png" alt="img"></p><p>当阻塞时间达到永久，就形成了死锁。</p><p>在事务中，一旦两个及以上的事务在同一资源上相互占用，并请求锁定对方占用的资源，就会引发死锁现象。</p><p>解决思路</p><ol><li>查询时间达到锁的超时时间后放弃请求</li><li>使用较低的隔离级别，让持有锁的时间减短，减少锁竞争</li><li>避免事务中用户交互，同时尽量顺序访问对象</li><li>…….</li></ol><p>不同的存储引擎对死锁实现了不同的死锁检测和死锁超时机制，因此大家在考虑死锁的解决方案的时候一定要结合数据库存储引擎的实现方案，并且做好事务日志，以便在问题发生时进行有效排查和高效解决。</p><p>事务的阻塞和死锁的出现实际上是多个进程并发的必然结果，大家如果想了解更多关于有关并发和锁，可以自行了解相关知识。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇笔者带大家初识数据库事务，初步了解了：</p><ol><li><p>什么是数据库、什么是锁和事务;</p></li><li><p>事务的四个特性：原子性、隔离性、一致性、持久性;</p></li><li><p>数据库读写出现的情况：脏读、幻读和不可重复读;</p></li><li><p>事务的隔离级别;</p></li><li><p>死锁的出现和解决思路</p></li></ol><p>因为篇幅有限，这里只能浅尝辄止。数据库是一门庞大复杂又极其重要的学科，如果大家有兴趣，鼓励大家自己凿渠引水，因笔者知识有限，文章内容所述难免存在谬误，恳请广大读者斧正。</p><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p>数据库学习《SQL学习指南》，《高性能MYSQL》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本篇共2895字，阅读大约需要6分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本次将向大家科普一些数据库事务相关知识。为什么选择数据库作为本次介绍的主角？&lt;/p&gt;
&lt;p&gt;数据库是现代网络的重要组成部分。在信息爆炸的大数据时代，各行各业都因为大幅爆发的数据而正变得蒸蒸日上；海量，多样且在高速产生的数据正迸发着前所未有的价值。可以说，数据改变了我们的生活，也在创造我们的未来。因此，我们越来越需要更加灵活，功能强大的数据库来帮助我们存储数据，处理数据。随着时代的发展，掌握数据库操作相关技术已经是从事ICT行业的相关人员的必备选择。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VRRP入门</title>
    <link href="http://yoursite.com/2019/06/05/vrrp/"/>
    <id>http://yoursite.com/2019/06/05/vrrp/</id>
    <published>2019-06-05T02:01:56.000Z</published>
    <updated>2019-07-26T14:13:41.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着移动办公、网上购物、即时通讯、互联网金融、互联网教育等业务蓬勃发展，网络承载的业务越来越多，越来越重要。所以如何保证网络的不间断传输成为网络发展过程中急需解决的一个问题。</p><p>对此，其中一种解决方案是，使用一套使用一套冗余备份机制，避免传统组网引发的单点故障，以便在路由器出现故障的时候及时进行链路切换，保证业务平滑进行。</p><a id="more"></a><p>传统解决方案</p><ol><li>配备多台路由器解决单点故障</li><li>使用动态路由协议解决多网关冲突，实现链路回切</li></ol><p>但是传统方案依然存在几个问题</p><ol><li>一些动态路由协议使用广播报文进行链路切换速度上比较缓慢</li><li>在许多情景下可能会不支持使用动态路由</li></ol><p>于是，VRRP应运而生。</p><h2 id="VRRP的基本概念"><a href="#VRRP的基本概念" class="headerlink" title="VRRP的基本概念"></a>VRRP的基本概念</h2><p><strong>VRRP</strong></p><blockquote><p>虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议。</p><p>VRRP能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现网关的备份</p></blockquote><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>采用VRRP的链路保护机制比依赖动态路由协议的广播报文来进行链路切换的时间更短，同时弥补了不能使用动态路由情况下的链路保护。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><img src="/2019/06/05/vrrp/vrrp_1.png" alt="1559704280150"></p><ul><li><p>VRRP路由器：运行VRRP的设备，它可能属于一个或多个虚拟路由器。</p></li><li><p>虚拟路由器(备份组):同一个广播域的一组路由器组织成一个虚拟路由器，备份组中的所有路由器一起，共同提供一个虚拟IP地址，作为内部网络的网关地址。</p></li><li><p>虚拟IP地址：虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。</p></li><li><p>IP地拥有者:如果一个VRRP路由器将虚拟路由器的IP地址作为真实的接口地址，则该设备是IP地址拥有者。</p></li><li><p>虚拟MAC地址：是虚拟路由器根据虚拟路由器ID生成的MAC地址。 当虚拟路由器回应ARP请求时，使用虚拟MAC地址，而不是接口的真实MAC地址。</p></li><li><p>主IP地址：从接口的真实IP地址中选出来的一个主用IP地址，通常选择配置的第一个IP地址。<br>VRRP广播报文使用主IP地址作为IP报文的源地址。 </p></li><li><p>主（Master）路由器：在同一个备份组中的多个路由器中，只有一台处于活动状态，只有主路由器能转发以虚拟IP地址作为下一跳的报文。</p></li><li><p>备份（Backup）路由器：在同一个备份组中的多个路由器中，除主路由器外，其他路由器均为备份路由器，处于备份状态。</p></li></ul><p><strong>状态机</strong></p><ul><li>VRRP有三种状态：初始状态、活动状态、备份状态.其状态切换过程如下：</li></ul><p><img src="/2019/06/05/vrrp/1559704314623.png" alt="1559704314623"></p><p><strong>协议报文</strong></p><p>vrrp只有一种报文：Advertisement报文；其目的IP地址是224.0.0.18（组播地址），目的MAC地址是01-00-5e-00-00-12，协议号是112</p><p>下面介绍vrrp的两种主要的工作模式：主备备份和负载分担</p><h2 id="VRRP主备备份"><a href="#VRRP主备备份" class="headerlink" title="VRRP主备备份"></a>VRRP主备备份</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="选举master"><a href="#选举master" class="headerlink" title="选举master"></a>选举master</h4><p>选举规则：1. 比较优先级 2. 优先级相同的时候，存在master则保持master状态 3. 没有master则比较接口IP地址，大的当选master</p><h4 id="备份组状态维持"><a href="#备份组状态维持" class="headerlink" title="备份组状态维持"></a>备份组状态维持</h4><ol><li>master周期性发送vrrp通告报文给组内设备，从而通知自己处于正常状态</li><li>主备切换 条件：1. master主动放弃，发送优先级为0的通告报文 2. master故障，等待Master_Down_Interval定时器超时，选举产生master。这个 切换时间叫Skew_Time，计算方式（256－Backup设备的优先级）/256（单位秒）</li><li>Master_Down_Interval定时器取值：<code>3×Advertisement_Interval＋Skew_Time</code>（单位秒）。</li></ol><h4 id="主备回切"><a href="#主备回切" class="headerlink" title="主备回切"></a>主备回切</h4><ol><li><p>如果原故障master路由器恢复，发现收到RouterB的VRRP报文中的优先级比自己低，RouterA立即抢占成为Master。</p><p>抢占模式：</p><ul><li>默认高优先级backup路由器可以抢占低优先级master路由器位置，但是如果IP地址拥有者是可用的，则它总是处于抢占的状态，并成为Master设备</li><li>注意抢占延时，默认为0，但是为了防止在网络不稳定的情况下频繁切换导致流量中断，可以设置延时时间稍长</li></ul></li><li><p>注意：如果VRRP的上行链路故障，由于主备通告正常，将无法引起主备切换</p><p>解决方法：利用VRRP的联动功能监视上行接口或链路故障，主动进行主备切换。</p></li></ol><p><img src="/2019/06/05/vrrp/1559707111077.png" alt="1559707111077"></p><h2 id="VRRP负载分担"><a href="#VRRP负载分担" class="headerlink" title="VRRP负载分担"></a>VRRP负载分担</h2><ul><li>负载分担是指多个VRRP备份组同时承担业务转发,从而解决流量分担不均，master负担过重的情况</li><li>负载分担方式需要建立多个VRRP备份组，各备份组的Master设备分担在不同设备上；单台设备可以加入多个备份组，在不同的备份组中扮演不同的角色。</li></ul><p><img src="/2019/06/05/vrrp/1559707202844.png" alt="1559707202844"></p><h2 id="VGMP简介"><a href="#VGMP简介" class="headerlink" title="VGMP简介"></a>VGMP简介</h2><p>VRRP虽然可以解决单点故障，实现主备备份，但是在配置防火墙的时候，由于防火墙功能的特殊性，在对其进行主备备份时，传统VRRP方式无法实现主、备用防火墙状态的一致性。无法实现VRRP状态一致性以及会话表状态的备份</p><p>此时，我们需要引入<strong>VGMP</strong>（VRRP Group Management Protocol）</p><p>VGMP提出VRRP管理组的概念，将同一台防火墙上的多个VRRP备份组都加入到一个VRRP管理组，由管理组统一管理所有VRRP备份组。通过统一控制各VRRP备份组状态的切换，来保证管理组内的所有VRRP备份组状态都是一致的。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>当防火墙上的VGMP为Active/Standby状态时，组内所有VRRP备份组的状态统一为Active/Standby状态。</li><li>状态为Active的VGMP也会定期向对端发送HELLO报文，通知Standby端本身的运行状态（包括优先级、VRRP成员状态等）</li><li>VGMP HELLO报文发送周期缺省为1秒。当Standby端三个HELLO报文周期没有收到对端发送的HELLO报文时，会认为对端出现故障，从而将自己切换到Active状态。</li></ul><p><img src="/2019/06/05/vrrp/1559707907266.png" alt="1559707907266"></p><h4 id="VGMP管理机制"><a href="#VGMP管理机制" class="headerlink" title="VGMP管理机制"></a>VGMP管理机制</h4><p><strong>状态一致性管理</strong></p><p>VGMP管理组控制所有的VRRP备份组统一切换。</p><p><strong>抢占管理</strong></p><p>当原来出现故障的主设备故障恢复时，其优先级也会恢复，此时可以重新将自己的状态抢占为主。</p><p>用VGMP实现防火墙的备份以及故障自动迁移从而保证业务连续性的方法也属于防火墙的双机热备技术的一部分，因为篇幅有限，这里不再展开。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们从现实一个问题作为切入点，简单介绍了利用VRRP做路由冗余备份，同时针对防火墙的特性，引申出VGMP的概念，也算是揭开了防火墙神秘面纱的一角。网络安全越来越成为我们生活中不可忽视的一部分，对于安全方面知识，下次有机会我们再继续讲述吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着移动办公、网上购物、即时通讯、互联网金融、互联网教育等业务蓬勃发展，网络承载的业务越来越多，越来越重要。所以如何保证网络的不间断传输成为网络发展过程中急需解决的一个问题。&lt;/p&gt;
&lt;p&gt;对此，其中一种解决方案是，使用一套使用一套冗余备份机制，避免传统组网引发的单点故障，以便在路由器出现故障的时候及时进行链路切换，保证业务平滑进行。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="ICT" scheme="http://yoursite.com/tags/ICT/"/>
    
      <category term="网络工程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo入门搭建</title>
    <link href="http://yoursite.com/2019/06/03/hello-hexo/"/>
    <id>http://yoursite.com/2019/06/03/hello-hexo/</id>
    <published>2019-06-02T16:54:56.000Z</published>
    <updated>2019-07-18T02:34:16.952Z</updated>
    
    <content type="html"><![CDATA[        <div id="aplayer-sBSmNDGF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-sBSmNDGF"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "出发",              author: "窦唯",              url: "http://music.163.com/song/media/outer/url?id=77393.mp3",              pic: "http://p2.music.126.net/vtuYXrzrc1mNIpr6WbynYQ==/109951164050843663.jpg?param=130y130",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了大概三天的时间，总算大致把博客的雏形搞定了。虽然说很多东西最终都不是我自己完成的，只是在别人的基础上在表面进行敲敲打打（后悔自己学习了后端，囧Orz）但不管怎样，没有文章的博客终归只是没有灵魂的躯壳，尽管自己的水平有限，但是还是希望能通过书写自己的一点一滴来见证自己的成长吧！</p><p>现在就开始我们今天的内容——hexo博客的搭建</p><a id="more"></a><hr><h2 id="初识Hexo"><a href="#初识Hexo" class="headerlink" title="初识Hexo"></a>初识Hexo</h2><p>先让我们了解一下hexo：</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>比起它的前辈wordpress，hexo最大的特点就是使用markdown编写文章，同时以node.js作为运行环境，你只需要在服务器上安装好node.js环境，就可以轻松安装hexo，这时你再回头看看wordpress的LAMP环境，是不是觉得繁琐又笨重呢？（hh其实hexo还是wordpress都是非常主流的博客框架，两者的优劣我们之后有时间或许可以再讨论）</p><h2 id="Hexo基本搭建"><a href="#Hexo基本搭建" class="headerlink" title="Hexo基本搭建"></a>Hexo基本搭建</h2><p><strong>知识前提</strong></p><p>安装hexo前你最好了解的基本知识</p><ol><li>markdown语法基础</li><li>node.js基本认识（其实用不到多少，但是最好能了解一点语法基础）</li><li>html、css基础（为你个性化博客很有帮助）</li><li>github相关知识（程序猿必备）</li></ol><p><strong>基础环境</strong></p><p>本人用的Win10</p><h3 id="搭建的基本流程"><a href="#搭建的基本流程" class="headerlink" title="搭建的基本流程"></a>搭建的基本流程</h3><blockquote><p>环境配置-&gt;本地调试-&gt;服务器部署</p></blockquote><h4 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h4><p><strong>安装git bash</strong></p><p>首先本地安装Git，具体可以自行百度。</p><p>安装完后再任意目录下点击右键</p><p><img src="/2019/06/03/hello-hexo/gitbash.png" alt="1559494852974">    </p><p>进入git bash，之后我们的操作都将在这里进行</p><p>（PS：实测cmd也可以，如果遇到一些操作在git bash里得不到响应可以在cmd中尝试进行，注意要在相同的路径下面）</p><p><strong>安装node.js</strong></p><p>首先安装好node.js环境，直接<a href="https://www.baidu.com/link?url=tsLvkFN4hyDOi_ejiKpM3c6W8yAJ1rwGwDZotldsgjO&wd=&eqid=a2cbec9f00038dbd000000065cf3fb8d" target="_blank" rel="noopener">官网</a>下载就行了</p><p>安装好后查看版本</p><p>正常无误即可</p><p><strong>安装hexo</strong></p><p>进入gitbash，使用node.js的包管理器npm，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install -g hexo</span><br></pre></td></tr></table></figure><p>等待安装完成即可</p><p>####2.本地调试</p><p>安装完成后在自己想要放博客的文件夹根目录下，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo init</span><br></pre></td></tr></table></figure><p>可以看到hexo生成以下文件</p><ul><li>node_modules（项目依赖包）</li><li>public（存放生成页面）</li><li>scaffolds：命令生成文章等的模板</li><li>source：资源库，放置比如文章、跳转页面等</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>package.json：项目所需模块项目的配置信息</li></ul><p>这时你已经可以启动你的博客了，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean    //清除之前的配置，防止博客配置出错的必要操作</span><br><span class="line">hexo generate  //可缩写为hexo g   创建资源文件</span><br><span class="line">hexo server    //可缩写为hexo s   启动server服务器</span><br></pre></td></tr></table></figure><p>当显示下面代码时说明启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$INFO  Start processing</span><br><span class="line">$INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop</span><br></pre></td></tr></table></figure><p>按流程输入<code>localhost:4000</code>当你看到下图说明基本配置成功了    <img src="/2019/06/03/hello-hexo/hexo_bg.png" alt="1559496074362"></p><h4 id="3-服务器部署"><a href="#3-服务器部署" class="headerlink" title="3.服务器部署"></a>3.服务器部署</h4><p>现在我们就要在公网上部署hexo了</p><p>这里我用的是Github Page对博客进行托管，有条件的同学也可以自己部署到服务器上，这是暂时不提。</p><p>首先需要在GitHub上新建一个仓库，命名形式为<code>yourusername.github.io</code>（<strong>yourusername是你的git账户,重要</strong>)</p><p>然后进入setting查看是否开启</p><p><img src="/2019/06/03/hello-hexo/github1.png" alt="img"></p><p><img src="/2019/06/03/hello-hexo/github2.png" alt="img"></p><p>接着创建ssh密钥对，将公钥放在GitHub上</p><p>在全局setting-&gt;SSH and GPG keys-&gt;new SSH keys添加</p><p><img src="/2019/06/03/hello-hexo/github3.png" alt="img"></p><p>如何本地创建SSH密钥对，请查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$git config --global user.email &quot;email@example.com&quot;</span><br><span class="line"></span><br><span class="line">$ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>接着打开博客文件夹根目录，前往<code>_config.yml</code>文件，找到如下字段，修改自己的repo</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:yourusername/yourusername.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后在gitbash输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>依次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate  //可缩写为hexo g</span><br><span class="line">hexo deploy    //可缩写为hexo d  部署hexo</span><br></pre></td></tr></table></figure><p>打开<code>https://yourgithubname.github.io</code>，看到与上一步相同的页面，证明博客搭建完成</p><p>至此，博客的基本搭建基本完成。</p><p>接着如果需要书写博客，使用如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;layout&gt; &quot;title&quot;</span><br></pre></td></tr></table></figure><p>这里的<code>&lt;layout&gt;</code>对应我们要添加的内容，如果是<code>posts</code>就是添加新的文章，如果是<code>page</code>就是添加新的页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish &lt;layout&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p><p>接着重启就行</p><p>​    </p><h2 id="hexo优化配置"><a href="#hexo优化配置" class="headerlink" title="hexo优化配置"></a>hexo优化配置</h2><p>虽然搭建了基本的博客，但是每次初始化时都要花很多时间（可以但没必要）</p><p>因此我们可以写一个脚本自动完成固定命令的执行</p><p>新建一个txt文件，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>保存后将后缀名改成<code>.bat</code>就可以点击执行了</p><h2 id="个性化你的Hexo"><a href="#个性化你的Hexo" class="headerlink" title="个性化你的Hexo"></a>个性化你的Hexo</h2><p>博客真正让人充满激情的地方在于它可以让你个性化，真正把博客作为你自己的小天地，这次我就结合自己搭建博客的实例分析一下如何个性化自己的博客吧</p><h3 id="添加主题NEXT"><a href="#添加主题NEXT" class="headerlink" title="添加主题NEXT"></a>添加主题NEXT</h3><h3 id="sagiri主题实战应用"><a href="#sagiri主题实战应用" class="headerlink" title="sagiri主题实战应用"></a>sagiri主题实战应用</h3><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>搜索模块 config.yml没有注意空格</p><p>注意备份</p><p>require是node.js的语法。。src文件夹下估计是未打包的文件</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer-sBSmNDGF&quot; class=&quot;aplayer aplayer-tag-marker&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
            &lt;pre class=&quot;aplayer-lrc-content&quot;&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script&gt;
          var ap = new APlayer({
            element: document.getElementById(&quot;aplayer-sBSmNDGF&quot;),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: &quot;出发&quot;,
              author: &quot;窦唯&quot;,
              url: &quot;http://music.163.com/song/media/outer/url?id=77393.mp3&quot;,
              pic: &quot;http://p2.music.126.net/vtuYXrzrc1mNIpr6WbynYQ==/109951164050843663.jpg?param=130y130&quot;,
              lrc: &quot;&quot;
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        &lt;/script&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;花了大概三天的时间，总算大致把博客的雏形搞定了。虽然说很多东西最终都不是我自己完成的，只是在别人的基础上在表面进行敲敲打打（后悔自己学习了后端，囧Orz）但不管怎样，没有文章的博客终归只是没有灵魂的躯壳，尽管自己的水平有限，但是还是希望能通过书写自己的一点一滴来见证自己的成长吧！&lt;/p&gt;
&lt;p&gt;现在就开始我们今天的内容——hexo博客的搭建&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>用java优雅爬虫——Jsoup</title>
    <link href="http://yoursite.com/2019/05/19/love/"/>
    <id>http://yoursite.com/2019/05/19/love/</id>
    <published>2019-05-19T15:18:04.000Z</published>
    <updated>2019-07-18T01:16:41.932Z</updated>
    
    <content type="html"><![CDATA[<p>jsoup是一个用于处理真实HTML的Java库。它提供了一个非常方便的API，用于提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。</p><a id="more"></a><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ol><li><p>jsoup概述</p></li><li><p>使用场景</p><p>DOM解析</p><p>CSS选择器</p><p>HTML过滤</p></li><li><p>逻辑分析</p></li><li><p>总结</p></li></ol><h3 id="二、jsoup概述"><a href="#二、jsoup概述" class="headerlink" title="二、jsoup概述"></a>二、jsoup概述</h3><p>官方解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsoup是一个用于处理真实HTML的Java库。它提供了一个非常方便的API，用于提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。</span><br></pre></td></tr></table></figure><p>个人接触到Jsoup是在用java写爬虫时，苦恼于大量使用正则匹配不仅降低了代码的可读性，相对也比较费时费力。这时候，一款爬虫框架突然引入眼帘，那就是jsoup。作为一款轻量，功能强大的爬虫框架，jsoup让简单抓取网页信息变得优雅，便捷。</p><p>虽然是一个java库，但是它的使用逻辑却无比接近于jQuery，以至于只要是熟悉或是了解JQuery的人可以轻而易举地上手这款框架。</p><h3 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h3><h4 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h4><p>jsoup的dom解析异常简单吗，只需要new一个ducumnet对象即可实现获取这个网页元素，接下来以解析一个网页为例。可以看到，将网页转化成ducument类，之后的Element类以及其子类都可以看成是一个个节点，通过调用相关方法实现整个文件节点的遍历。同时，Element类的getElementByTag让人很容易联想到js中的相关方法，因此只要有点JS基础和java基础的人看这段代码都不会觉得陌生。</p><p>这里以查询学生成绩信息为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jsoupTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGrade</span><span class="params">(String stu_num, String id_num)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String testURL = <span class="string">"http://jwc.cqupt.edu.cn/showS tuQmcj.php"</span>;  <span class="comment">//目标网页</span></span><br><span class="line">        Connection con = Jsoup.connect(testURL);                    <span class="comment">//获取连接</span></span><br><span class="line">        con.data(<span class="string">"xh"</span>, stu_num);                                <span class="comment">//填写参数</span></span><br><span class="line">        con.data(<span class="string">"sfzh"</span>, id_num);</span><br><span class="line">        Document document = con.post();                         <span class="comment">//选择发送方式,获取整个网页信息，存在documnet类里</span></span><br><span class="line"></span><br><span class="line">        Element pTable = document.body().getElementsByClass(<span class="string">"pTable"</span>).get(<span class="number">0</span>);   <span class="comment">//通过class属性 ，获取子类元素</span></span><br><span class="line">        ;</span><br><span class="line">        Elements trs = pTable.getElementsByTag(<span class="string">"tbody"</span>).get(<span class="number">0</span>).children();</span><br><span class="line"></span><br><span class="line">        trs.forEach(tr -&gt; &#123;                                                               <span class="comment">//遍历&lt;tr&gt;标签</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!tr.children().isEmpty()) &#123;</span><br><span class="line">                Element element = tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!element.text().equals(<span class="string">"课程类型"</span>)) &#123;</span><br><span class="line">                    GradeInfo gradeInfo = <span class="keyword">new</span> GradeInfo();</span><br><span class="line">                    gradeInfo.setProperty(tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">0</span>).text());</span><br><span class="line">                    String term = tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">1</span>).text();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    System.out.println(term);</span><br><span class="line">                    System.out.println(tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">2</span>).text());</span><br><span class="line">                    System.out.println(tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">5</span>).text());</span><br><span class="line">                    System.out.println(tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">6</span>).text());</span><br><span class="line">                    System.out.println(tr.getElementsByTag(<span class="string">"td"</span>).get(<span class="number">7</span>).text());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        jsoupTest jsouptest = <span class="keyword">new</span> jsoupTest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsouptest.getGrade(<span class="string">"2017210246"</span>, <span class="string">"010033"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/05/19/love/love_2.png" alt="img"></p><p>只需要几行就可以完成对html的基本解析，而且所有的操作都可以用js的逻辑解释。或多或少比原生正则匹配要实用地多。</p><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>jsoup决心是想向前端靠齐了，除了基本的DOM解析操作外，它同时加入了CSS选择器，这个操作乍一看似乎没什么用处，但是当你真正去学习如何使用后你的就会发现这是多少好用。在针对较复杂地语句匹配时，使用选择器可以轻而易举地筛选出你想要的元素，可以帮你节省大量代码。</p><p>使用方法：可以用<code>Element.select(String selector)</code>和<code>Element.select(String selector)</code>实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBySelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       String testURL = <span class="string">"&lt;html&gt;"</span> +</span><br><span class="line">               <span class="string">"&lt;head&gt;&lt;/head&gt;"</span>+</span><br><span class="line">               <span class="string">"&lt;body&gt;"</span>+<span class="string">"&lt;span id=\"grade\"&gt;成绩&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"subject\"&gt;课程&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"name\"&gt;姓名&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"stunum\"&gt;学号&lt;/span&gt;"</span>+</span><br><span class="line">               <span class="string">"&lt;span class = \"score\"&gt;85&lt;/span &gt;"</span>+<span class="string">"&lt;span class = \"class\"&gt;语文&lt;/span&gt;"</span>+<span class="string">"&lt;span class = \"stuname\"&gt;小明&lt;/span class = \"number\"&gt;"</span>+<span class="string">"&lt;span&gt;201721001&lt;/span&gt;"</span>+</span><br><span class="line">               <span class="string">"&lt;span id=\"grade\"&gt;80&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"subject\"&gt;数学&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"name\"&gt;小明&lt;/span&gt;"</span>+<span class="string">"&lt;span id = \"stunum\"&gt;2017210001&lt;/span&gt;"</span>+</span><br><span class="line">               <span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>;  <span class="comment">//利用字符串拼接出HTML标签</span></span><br><span class="line">                     <span class="comment">//获取连接</span></span><br><span class="line"></span><br><span class="line">       Document document = Jsoup.parse(testURL);                         <span class="comment">//将HTML转化成可遍历地document类</span></span><br><span class="line">       Elements elements = document.select(<span class="string">"span:matchesOwn(^8)"</span>);</span><br><span class="line">       <span class="keyword">for</span> (Element element:</span><br><span class="line">            elements) &#123;</span><br><span class="line">           System.out.println(elements.text());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/05/19/love/love_3.png" alt="img"></p><p>CSS选择器类似于JQuery和CSS中使用的选择器，可以通过特定的选择器语法将对指定元素进行筛选</p><p>对于选择器的筛选，这里推荐一篇文章：<a href="https://blog.csdn.net/yueshutong123/article/details/81226430?utm_source=blogxgwz0" target="_blank" rel="noopener">详解JSOUP的Select选择器语法</a></p><h4 id="HTML过滤"><a href="#HTML过滤" class="headerlink" title="HTML过滤"></a>HTML过滤</h4><p>这个功能也是偶然看见的，不过现在想来也理所当然，过滤网页信息本身就是Jsoup分内的事。当时正在看XSS攻击方面的知识，突然发现jsoup在安全方面已早有考虑，已本身优秀的HTML解析为基础，抵御XSS攻击自然也是十分优秀。</p><p>XSS注入本质就是在HTML中插入特定的标签改变原来标签的含义，因此防止XSS攻击的本质是能分辨并及时过滤掉多余或是无效的HTML标签。对此，jsoup有一个白名单机制，通过clean方法可以一步通过白名单设置的过滤规则清理所有的标签，同时也会保留适当标签和禁止图片显示的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xss过滤</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsoupUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自带的basicWithImages 白名单</span></span><br><span class="line"><span class="comment">     * 允许的便签有a,b,blockquote,br,cite,code,dd,dl,dt,em,i,li,ol,p,pre,q,small,span,</span></span><br><span class="line"><span class="comment">     * strike,strong,sub,sup,u,ul,img</span></span><br><span class="line"><span class="comment">     * 以及a标签的href,img标签的src,align,alt,height,width,title属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Whitelist whitelist = Whitelist.basicWithImages();</span><br><span class="line">    <span class="comment">/** 配置过滤化参数,不对代码进行格式化 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Document.OutputSettings outputSettings = <span class="keyword">new</span> Document.OutputSettings().prettyPrint(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 富文本编辑时一些样式是使用style来进行实现的</span></span><br><span class="line">        <span class="comment">// 比如红色字体 style="color:red;"</span></span><br><span class="line">        <span class="comment">// 所以需要给所有标签添加style属性</span></span><br><span class="line">        whitelist.addAttributes(<span class="string">":all"</span>, <span class="string">"style"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">clean</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jsoup.clean(content, <span class="string">""</span>, whitelist, outputSettings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        String text = <span class="string">"&lt;a href=\"http://www.baidu.com/a\" onclick=\"alert(1);\"&gt;sss&lt;/a&gt;&lt;script&gt;alert(0);&lt;/script&gt;sss"</span>;</span><br><span class="line">        System.out.println(clean(text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、逻辑分析"><a href="#四、逻辑分析" class="headerlink" title="四、逻辑分析"></a>四、逻辑分析</h3><p>jsoup作为一款轻便的爬虫框架，全部由Jonathan Hedley独立写出，因此代码相比其他一些笨重的框架要简洁很多，我通过网上一些解析jsoup源码的博客，加深对jsoup的理解。废话不多说，让我们看看jsoup的魅力吧！</p><p><img src="/2019/05/19/love/love_4.png" alt="img"></p><p>借用别人博客里整理的图片，可以看到，让java能像js那样使用类似标签的嵌套存储的方法就是在这里就是利用自定义的node抽象类，将属性存储在类似树状的结构中这，这样做不仅有利于之后的DOM树解析，也容易遍历，有利于性能的提高。</p><p>我们再看看CSS选择器的实现逻辑。这是selector的源码列表</p><p><img src="/2019/05/19/love/love_5.png" alt="img"></p><p>jsoup在关于selector的实现大致是利用Evaluator抽象类，Selector选择的表达式都会通过QueryParser最终编译到对应的Evaluator类上，然后此类又有很多派生子类，从而分别实现不同功能。逻辑思路还算简单，但是具体代码我还不曾仔细研读，因此在此也不再赘述。不过其中进行嵌套实现对象的思路还是值得借鉴的。</p><p>在HTML过滤方面，jsoup防止XSS攻击的大致策略是</p><ol><li>将HTMl字符串解析成document对象，这样保证了无法通过注入一段无用的脚本和字符串拼接导致网页的功能发生了改变</li><li>将一些高频出现的危险系数较高的标签加入白名单进行提前过滤</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>jsoup在操作便捷度上已经展现了它的实力，但是在性能上，考虑到它的底层还是通过正则进行匹配，因此对于一些一些简单的HTML解析或许直接正则的最快的；但是，当HTML页面比较复杂，这便是jsoup大显身手的时候了。</p><p>但是jsoup还是有很多不足，例如</p><ol><li>只能处理静态页面，对于动态显示或者后端渲染后后的页面无法正常进行爬取，这时就需要利用其他的工具例如httpunit进行模拟的ajax请求。</li><li>jsoup总归还只是个人项目，在后期的维护方面还是存在一定的不确定性，如果需要用应用在一些大型的长久性的项目中还需三思。</li><li>jsoup的底层实现还是正则匹配，尽管jsoup本身够轻量，但它依然需要解析整个HTML，再进行进一步的搜索，因此在一些简单的网页解析中，肯定还是直接上正则来的直接来的方便。但是如果网页的结构足够复杂，使用正则的的代码量巨大，那么jsoup不失为一个不错的选择。</li></ol><p>总而言之，jsoup作为一款轻量的爬虫框架，在HTML解析方面的表现还是很不错的，如果平时希望偷点懒，节省点时间和代码量，完全推荐大家使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jsoup是一个用于处理真实HTML的Java库。它提供了一个非常方便的API，用于提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="学习总结" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>测试文章</title>
    <link href="http://yoursite.com/2019/05/15/test/"/>
    <id>http://yoursite.com/2019/05/15/test/</id>
    <published>2019-05-15T09:31:49.000Z</published>
    <updated>2019-07-18T01:59:07.908Z</updated>
    
    <content type="html"><![CDATA[<table><tr><td bgcolor="#B2D2F7"><font color="#FFFFFF">这是我的第一篇文章</font></td></tr></table><font color="red">现在开始测试</font><a id="more"></a><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://lc-dtfowewy.cn-n1.lcfile.com/e84e4b6519b04ed3c497/400%E7%B1%B3.mp4","pic":"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=888502118,2306802280&fm=26&gp=0.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% dplayer <span class="string">"url=视频地址"</span> <span class="string">"pic=图片地址"</span> <span class="string">"loop=yes"</span> <span class="string">"theme=#FADFA3"</span> <span class="string">"autoplay=false"</span>%&#125;</span><br></pre></td></tr></table></figure><hr><p><mark>我是黑体字(不，你是高亮)</mark><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="red">我是红色</font><br><font color="#008000">我是绿色</font><br><font color="Blue">我是蓝色</font><br><font size="5">我是尺寸</font><br><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mark&gt;我是黑体字(不，你是高亮)&lt;/mark&gt;</span><br><span class="line">&lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font color=red&gt;我是红色&lt;/font&gt;</span><br><span class="line">&lt;font color=#008000&gt;我是绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;</span><br><span class="line">&lt;font size=5&gt;我是尺寸&lt;/font&gt;</span><br><span class="line">&lt;font face="黑体" color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>首先是插入图片</p><p><img src="/2019/05/15/test/test.png" alt="1558140286886"></p><p>另外的测试方法</p><p>尝试插入音频的另一种方法</p>        <div id="aplayer-ZthDzplC" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZthDzplC"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "可以了",              author: "陈奕迅",              url: "http://lc-dtfowewy.cn-n1.lcfile.com/5cd909f1bdc4f3ba7ff5/1.COUNTING%20STARS%204.17.wav",              pic: "http://pic.58pic.com/58pic/15/68/59/71X58PICNjx_1024.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer <span class="string">"可以了"</span> <span class="string">"陈奕迅"</span> <span class="string">"音乐地址"</span> <span class="string">"图片地址"</span>  %&#125;</span><br></pre></td></tr></table></figure><p>然后是插入URL</p><p><a href="https://github.com/DIYgod/diygod.me/blob/hexo/source/images/2018-1.jpg" target="_blank" rel="noopener">这是URL</a></p><p>最后插一下代码块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.FastClick = <span class="built_in">require</span>(<span class="string">'fastclick'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'lazyload'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'fancybox'</span>)(<span class="built_in">window</span>.$);</span><br><span class="line"><span class="built_in">window</span>.notie = <span class="built_in">require</span>(<span class="string">'corner-notie'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./motion'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./affix'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./pisces'</span>)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./scrollspy'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./post-details'</span>)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./bootstrap'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./evanyou'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./leancloud'</span>)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./share'</span>)();</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./scroll'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./since'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./title'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./type'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./kanban'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./mix'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./clipboard'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./pjax'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./online'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./search'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./cursor-effects'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;#B2D2F7&quot;&gt;&lt;font color=&quot;#FFFFFF&quot;&gt;这是我的第一篇文章&lt;/font&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;font color=&quot;red&quot;&gt;现在开始测试&lt;/font&gt;
    
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/05/15/hello-world/"/>
    <id>http://yoursite.com/2019/05/15/hello-world/</id>
    <published>2019-05-15T01:46:36.286Z</published>
    <updated>2019-05-19T02:02:27.891Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
